var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/prologue/introduction/",title:"Introduction",description:"Ludwig is a lazy functional logic programming language designed to compose and play music.",content:`Getting started # The easiest way to play with Ludwig is through the playground.
If you\u0026rsquo;d like to build Ludwig from source, clone the source and build the project using the luwig npm script, my tests in particular were done on macOS using npm v9.4.0 and node v19.6.1.
git clone git@github.com:fuzzypixelz/jam0004.git cd ludwig npm run ludwig open dest/index.html Next, webpack should generate the build files under dest/. Simply open the index.html with your browser of choice (Chromium-based browsers are recommended).
Rationale # Ludwig is Innf107 and fuzzypixelz\u0026rsquo; submission for the 4th Lang Jam. This edition\u0026rsquo;s theme is:
The sound(ness) of one hand typing
At first we thought of making a language where all tokens can be typed using only one side of the keyboard — we would quickly get disenchanted with this idea. After a fair bit of Brainstorming™ we thought of making a language which plays musical notes while de-duplicating notes of the same pitch (more on this later).
We then decided to design Ludwig as a lazy functional logic programming language on the browser.
`}),e.add({id:1,href:"/docs/prologue/syntax/",title:"Syntax",description:"Ludwig Syntax",content:`In the following expr* means zero or more repetitions of the syntax form expr, while expr+ means one or more repetitions or expr and expr? means zero or one occurrences of expr and finally expr | expr' means either the form expr or expr'. For example an non-negative integer literal can be written as:
digit = '0' | ... | '9' number = digit+ Likewise we define identifiers:
identifier_start = ('A' | ... | 'Z' | 'a' ... 'z') identifier = identifier_start (identifier_start | '_' | digit)* Musical notes # Ludwig has special syntax for expressing the value, pitch and octave of a musical note using the following syntax:
pitch = | 'A' | 'A#' | 'Bb' | 'B' | 'A' | 'C' | 'C#' | 'Db' | 'D' | 'D#' | 'Eb' | 'E' | 'F' | 'F#' | 'Gb' | 'G' | 'G#' | 'Ab' | '_' octave = (number '/')? value = (number '/')? note = value pitch octave Values are expressed as their own inverse fractions. For example 8/C/4 denotes the Middle C note of value (i.e duration) 1/8. Underscore (i.e _) denotes a pause.
Lists # The syntax for (cons) lists is shared by many other ML-family languages:
list = | '[' ((expr ',')* expr)? ']' | expr ':' expr Choice # Choice expressions are of the form lhs | rhs; Ludwig evaluates both lhs and rhs and keeps both results unless one of them fails to compute; in which case only the other one is left. Of course, if both options fail then the choice also fails.
choice = expr '|' expr Unification # There plus = symbol in Ludwig doesn\u0026rsquo;t mean assignment but rather unification which you can think of as \u0026lsquo;structural equality\u0026rsquo;, with some caveats. Unification expressions always contain continuation expressions.
unify = expr '=' expr 'in' expr Bindings # Because there is no explicit notion of assignment bindings look a bit different, though there is syntax sugar to alleviate this.
binding = | 'let' identifier 'in' expr | 'let' identifier '=' expr 'in' expr | 'const' identifier 'in' expr The second form reduces to the first by putting a unification expression in its body. This looks like regular assignment but is quite different semantically.
Constants are defined by using the const keyword, see the next section for the difference between the two.
Lambdas # Lambdas (i.e anonymous function expressions) share the same syntax with Haskell-like programming languages:
lambda = '\\' identifier '-\u0026gt;' expr Applications # Like you would expect function application is curried and is done by simply juxtaposition:
apply = expr expr Summary # expr = | note | list | choice | unify | lambda | apply `}),e.add({id:2,href:"/docs/prologue/languageconstructs/",title:"Language Constructs",description:"Language Constructs",content:`As a functional logic language, Ludwig does not need many language constructs to be expressive. For the precise syntax, refer to Syntax.
Notes # Of course, no language for creating music would be complete without a way to express the notes that should be played. In fact, these are one of the only kinds of literals that Ludwig has dedicated syntax for.
Because every Ludwig program is just one large expression that is lazily evaluated and played, individual notes are already valid songs.
C 1/B/2 Lists # Maybe you like minimalism, but for the rest of us, individual notes are not exactly the most exciting songs. Ludwig programs can use lists to play multiple notes in sequence.
Lists can be written directly as list literals
[C, D, E, F, G, A, B, C/5] or by prepending (\u0026lsquo;cons\u0026rsquo;-ing) one or more elements to an existing list
C : D : [E, F, G, A, B, C/5] In fact, every closed list expression of the form [A, B, C] is just syntactic sugar for prepending all elements to an empty list (A : B : C : [])
Basic Let Bindings # It is often useful to give names to values to refer to them later. This is where let bindings come in.
let cmaj = [C, E, G] in [cmaj, cmaj] Notice how this evaluates to the nested list
[[C, E, G], [C, E, G]] Thanks to a lack of types, Ludwig has no issues with an \u0026lsquo;ill-typed\u0026rsquo; expression of this form.
Also, because Ludwig is lazy, let-bound expressions are only evaluated when necessary, so infinite loops do not hang the program unless they are actually used
let loop = loop in C This behavior is crucial for creating infinitely playing tracks. (Reload this tab to make it stop)
let scale = [C, D, E, F, G, A, B] in let loop = scale : loop in loop Functions # Like most functional languages, functions in Ludwig are represented via lambda expressions. For example, a function that returns its argument without doing anything with it might look like this1.
\\x -\u0026gt; x Functions in Ludwig only ever take exactly one argument. Functions taking multiple arguments can be emulated via currying. This means that instead of taking two arguments, a function takes one argument and returns another function that takes the second argument.
Example: this is a function that takes two arguments and bundles them up in a list.
\\x -\u0026gt; \\y -\u0026gt; [x, y] Calling a function doesn\u0026rsquo;t need parentheses, similar to other functional languages like Haskell or OCaml.
let playEachTwice = \\x -\u003e \\y -\u003e [x, x, y, y] in playEachTwice C E
Free Variables and Unification # The previous constructs already provided a solid foundation for a functional language, but Ludwig is also a logic language.
In a logic programming language, variables don\u0026rsquo;t need to have values immediately. One can define a variable without ever giving it a value.
let x in x How do you do anything useful with these variables? With unification!
A unification expression of the form
expr1 = expr2 in expr3 asserts that expr1 and expr2 should be equal. If there are any free (i.e. not yet substituted) variables in either of these, then these will be substituted so that expr1 and expr2 are equal. If this is not possible, the expression will fail.
For example, in the expression
let x in let y in x = C in E = y in [x, y] x is substituted with C and y is substituted with E so that both unification expressions are satisfied.
Why is this useful? Because nothing prevents the arguments to a unification expression to be more complicated structures! For example, extracting the first element of a list could be achieved with this function
let head = \\list -\u003e let first in let rest in list = (first : rest) in first in head [C, D, E] Fun fact: \u0026lsquo;basic\u0026rsquo; let bindings of the form let x = expr in expr2 are just syntactic sugar for free let bindings and unification (let x in x = expr in expr2)
Choice # How do you play two notes at the same time? Say you want to play a C major chord. This would involve playing C, E, and G at the same time.
How do you write an expression in Ludwig that does this? Well, you write one that returns all three notes at the same time. This is what logical/non-deterministic choice does.
C | E | G The intuition for choice is really that a choice expression returns all values at the same time (though the implementation is closer to spatial choice from the Verse Calculus).
Applying any operation to the result of a choice is equivalent to the choice between applying it to all results individually
e.g.
let f = \\x -\u003e [C, x] in f (C | E | G) is equivalent to
[C, C] | [C, E] | [C, G] If unification inside any branch of the choice fails, it is ignored. In other words, failure | something is equivalent to something.
This can be used to emulate ML-style pattern matching
let nextOctave = \\note -\u003e (note = C in C/5) | (note = D in D/5) | (note = E in E/5) | (note = F in F/5) | (note = G in G/5) | (note = A in A/5) | (note = B in B/5) in nextOctave C Constants # You may notice that Ludwig doesn\u0026rsquo;t have any built-in syntax for numbers or any data structures besides lists. Does this mean you cannot express anything non-trivial?
No! Ludwig has the ability to declare constants (values that only unify with themselves) that are powerful enough to express any algebraic data type.
As an example, consider the standard inductive definition of natural numbers as peano numbers (given in Haskell syntax)
data Nat = Z | S Nat Defining constants for the possible data constructors (Z and S in this case) is enough to express these with full support for pattern matching
const Z in const S in let add = \\n -\u003e \\m -\u003e (n = Z in m) | (let nMinus1 in (S nMinus1) = n in S(add nMinus1 m)) in let replicate = \\n -\u003e \\x -\u003e (n = Z in []) | (let nMinus1 in (S nMinus1) = n in x : (replicate nMinus1 x)) in replicate (add (S (S Z)) (S (S (S Z)))) C You may notice that this example is not playable. This is because Ludwig can only play notes, lists of notes, or choices between the former. If you type this into the playground anyway, you will see a (slightly cryptic) runtime error. What would it even mean to play the function \\x -\u0026gt; x?\u0026#160;\u0026#x21a9;\u0026#xfe0e;
`}),e.add({id:3,href:"/docs/prologue/",title:"Ludwig",description:"Ludwig documentation.",content:""}),e.add({id:4,href:"/docs/",title:"Docs",description:"Ludwig Docs",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()